# lab4实验报告

## **linkat**实现

首先需要根据虚拟地址指针，得到真实的string。

和fstat不同，这个链接的建立和解除一定是建立在那颗文件树上面的（因为没有文件描述符呀）所以跟当前的task一点关系都没有。

因此，需要在vfs中实现建立链接的函数，在内核中，~~从当前节点调用。~~，我认真看了一下下efs的实现，他只有单层目录，而不是目录树的形式，所以，也没实现pwd。。。

换而言之，直接从根节点调用根节点的建立链接的函数即可。（辣鸡！）

而根节点，它又是放在fs/inode.rs当中去的，所以在那之后开个函数调用一下就好了

## **unlinkat**实现

同上（不管怎样我都没办法压缩进200个字，干脆无所谓了）。

## **fstat**实现

fstat是根据文件描述符去找到对应的文件信息。所以首先第一个就是去找到对应的task中的文件描述符表，然后去找到文件描述符。由文件描述符去vec里面找到对应的文件OSnode。

因为文件本身是个多态实现的多个类型的公共接口，所以需要对fs模块下的stdio和file分别实现fstat，很显然，stdin和stdout的inode号都是确定的——0和1。其他结构也可以直接写。而file则需要调用文件系统的接口函数，得到相关信息。（相关函数我放在vfs增加的函数里面描述，因为那是文件系统的部分）

最后，在内核态找到对应数据结构的物理地址，填充进去就好了。

## **vfs**需要增加的函数和内容

因为他使用了操作系统内核和文件系统分离的设计，所以，需要在vfs中加上一定的函数，来实现上述的一些功能，并供内核调用。需要实现的函数及功能如下：

Inode结构体中添加vfs_inode_id，同时，需要在new的各个位置添加该字段(包括在efs文件中的new，那里的根节点的inode设为0)

DiskInode结构体中添加nlink字段，硬链接是让内存中的inode直接指向同一个磁盘inode，另外，需要在初始化的时候，让他的nlink数量设为1

get_inode:直接返回vfs_inode_id就好了

get_mode

get_nlink

add_one_nlink

delete_one_nlink